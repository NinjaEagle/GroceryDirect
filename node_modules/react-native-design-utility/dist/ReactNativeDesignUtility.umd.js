(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-native')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-native'], factory) :
    (factory((global.ReactNativeDesignUtility = {}),global.React,global.ReactNative));
}(this, (function (exports,React,reactNative) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        symbolTag = '[object Symbol]';

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Symbol$1 = root.Symbol,
        splice = arrayProto.splice;

    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map'),
        nativeCreate = getNative(Object, 'create');

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoize(function(string) {
      string = toString(string);

      var result = [];
      if (reLeadingDot.test(string)) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var lodash_get = get;

    var color = {
        black: '#212121',
        greyDarkest: '#242424',
        greyDarker: '#616161',
        greyDark: '#757575',
        grey: '#9e9e9e',
        greyLight: '#bdbdbd',
        greyLighter: '#e0e0e0',
        greyLightest: '#eeeeee',
        white: '#fff',
        redDarkest: '#b71c1c',
        redDarker: '#c62828',
        redDark: '#d32f2f',
        red: '#f44336',
        redLight: '#ef5350',
        redLighter: '#e57373',
        redLightest: '#ef9a9a',
        blueDarkest: '#0d47a1',
        blueDarker: '#1565c0',
        blueDark: '#1976d2',
        blue: '#2196f3',
        blueLight: '#42a5f5',
        blueLighter: '#64b5f6',
        blueLightest: '#90caf9',
        purpleDarkest: '#4a148c',
        purpleDarker: '#6a1b9a',
        purpleDark: '#7b1fa2',
        purple: '#9c27b0',
        purpleLight: '#ab47bc',
        purpleLighter: '#ba68c8',
        purpleLightest: '#ce93d8',
        greenDarkest: '#1b5e20',
        greenDarker: '#2e7d32',
        greenDark: '#388e3c',
        green: '#4caf50',
        greenLight: '#66bb6a',
        greenLighter: '#81c784',
        greenLightest: '#a5d6a7',
    };
    var theme = {
        text: {
            size: {
                sm: 14,
                base: 16,
                md: 18,
                lg: 20,
                xl: 24,
            },
            weight: {
                light: '200',
                normal: '400',
                bold: '700',
            },
            spacing: {
                tight: 0.8,
                normal: 1,
                wide: 1.5,
            },
            lineHeight: {
                none: 1,
                tight: 1.25,
                normal: 1.5,
                large: 2,
            },
            fonts: {
                base: null,
            },
        },
        color: color,
        space: {
            xs: 8,
            sm: 16,
            md: 24,
            lg: 36,
            xl: 40,
        },
        radius: {
            xs: 6,
            sm: 10,
            base: 14,
            lg: 20,
            xl: 30,
        },
        opacity: {
            none: 0,
            low: 0.3,
            demi: 0.5,
            high: 0.8,
            base: 1,
        },
        shadows: [
            {
                shadowColor: color.black,
                shadowOffset: {
                    width: 0,
                    height: 0,
                },
                shadowOpacity: 1,
                shadowRadius: 1,
            },
            {
                shadowColor: color.black,
                shadowOffset: {
                    width: 0,
                    height: 0,
                },
                shadowOpacity: 0.6,
                shadowRadius: 5,
            },
        ],
        borders: [
            {
                borderWidth: 1,
                borderColor: color.black,
            },
            {
                borderWidth: 2,
                borderColor: color.black,
            },
            {
                borderWidth: 5,
                borderColor: color.black,
            },
        ],
        button: {
            disabled: {
                opacity: 0.5,
            },
        },
    };

    var UtilityThemeContext = React.createContext(theme);
    var UtilityThemeProvider = /** @class */ (function (_super) {
        __extends(UtilityThemeProvider, _super);
        function UtilityThemeProvider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                theme: _this.props.theme || theme,
            };
            return _this;
        }
        UtilityThemeProvider.prototype.render = function () {
            return (React.createElement(UtilityThemeContext.Provider, { value: this.state.theme }, this.props.children));
        };
        UtilityThemeProvider.defaultProps = {
            theme: null,
        };
        return UtilityThemeProvider;
    }(React.Component));

    function getDisplayName(wrappedComponent) {
        return ("Utility(" + wrappedComponent.displayName + ")" ||
            "Utility(" + wrappedComponent.name + ")" ||
            'Component');
    }
    function connect(Cp) {
        var _a;
        return _a = /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_1.prototype.render = function () {
                    var _this = this;
                    return (React.createElement(UtilityThemeContext.Consumer, null, function (val) { return React.createElement(Cp, __assign({ theme: val }, _this.props)); }));
                };
                return class_1;
            }(React.PureComponent)),
            _a.displayName = getDisplayName(Cp),
            _a;
    }

    var spaceUtils = function (props) {
        var _style = {};
        var themeSpace = lodash_get(props, ['theme', 'space']);
        if (themeSpace) {
            var mb = lodash_get(props, 'mb');
            if (mb) {
                if (typeof mb === 'string') {
                    var space = themeSpace[mb];
                    if (space) {
                        _style.marginBottom = space;
                    }
                }
                else if (typeof mb === 'number') {
                    _style.marginBottom = mb;
                }
            }
            var mt = lodash_get(props, 'mt');
            if (mt) {
                if (typeof mt === 'string') {
                    var space = themeSpace[mt];
                    if (space) {
                        _style.marginTop = space;
                    }
                }
                else if (typeof mt === 'number') {
                    _style.marginTop = mt;
                }
            }
            var mr = lodash_get(props, 'mr');
            if (mr) {
                if (typeof mr === 'string') {
                    var space = themeSpace[mr];
                    if (space) {
                        _style.marginRight = space;
                    }
                }
                else if (typeof mr === 'number') {
                    _style.marginRight = mr;
                }
            }
            var ml = lodash_get(props, 'ml');
            if (ml) {
                if (typeof ml === 'string') {
                    var space = themeSpace[ml];
                    if (space) {
                        _style.marginLeft = space;
                    }
                }
                else if (typeof ml === 'number') {
                    _style.marginLeft = ml;
                }
            }
            var my = lodash_get(props, 'my');
            if (my) {
                if (typeof my === 'string') {
                    var space = themeSpace[my];
                    if (space) {
                        _style.marginVertical = space;
                    }
                }
                else if (typeof my === 'number') {
                    _style.marginVertical = my;
                }
            }
            var mx = lodash_get(props, 'mx');
            if (mx) {
                if (typeof mx === 'string') {
                    var space = themeSpace[mx];
                    if (space) {
                        _style.marginHorizontal = space;
                    }
                }
                else if (typeof mx === 'number') {
                    _style.marginHorizontal = mx;
                }
            }
            var m = lodash_get(props, 'm');
            if (m) {
                if (typeof m === 'string') {
                    var space = themeSpace[m];
                    if (space) {
                        _style.margin = space;
                    }
                }
                else if (typeof m === 'number') {
                    _style.margin = m;
                }
            }
            var pb = lodash_get(props, 'pb');
            if (pb) {
                if (typeof pb === 'string') {
                    var space = themeSpace[pb];
                    if (space) {
                        _style.paddingBottom = space;
                    }
                }
                else if (typeof pb === 'number') {
                    _style.paddingBottom = pb;
                }
            }
            var pt = lodash_get(props, 'pt');
            if (pt) {
                if (typeof pt === 'string') {
                    var space = themeSpace[pt];
                    if (space) {
                        _style.paddingTop = space;
                    }
                }
                else if (typeof pt === 'number') {
                    _style.paddingTop = pt;
                }
            }
            var pr = lodash_get(props, 'pr');
            if (pr) {
                if (typeof pr === 'string') {
                    var space = themeSpace[pr];
                    if (space) {
                        _style.paddingRight = space;
                    }
                }
                else if (typeof pr === 'number') {
                    _style.paddingRight = pr;
                }
            }
            var pl = lodash_get(props, 'pl');
            if (pl) {
                if (typeof pl === 'string') {
                    var space = themeSpace[pl];
                    if (space) {
                        _style.paddingLeft = space;
                    }
                }
                else if (typeof pl === 'number') {
                    _style.paddingLeft = pl;
                }
            }
            var py = lodash_get(props, 'py');
            if (py) {
                if (typeof py === 'string') {
                    var space = themeSpace[py];
                    if (space) {
                        _style.paddingVertical = space;
                    }
                }
                else if (typeof py === 'number') {
                    _style.paddingVertical = py;
                }
            }
            var px = lodash_get(props, 'px');
            if (px) {
                if (typeof px === 'string') {
                    var space = themeSpace[px];
                    if (space) {
                        _style.paddingHorizontal = space;
                    }
                }
                else if (typeof px === 'number') {
                    _style.paddingHorizontal = px;
                }
            }
            var p = lodash_get(props, 'p');
            if (p) {
                if (typeof p === 'string') {
                    var space = themeSpace[p];
                    if (space) {
                        _style.padding = space;
                    }
                }
                else if (typeof p === 'number') {
                    _style.padding = p;
                }
            }
        }
        return _style;
    };

    var boxAlignUtils = function (props) {
        var _style = {};
        var center = lodash_get(props, 'center');
        if (center) {
            _style.justifyContent = 'center';
            _style.alignItems = 'center';
        }
        return _style;
    };

    var borderUtils = function (props) {
        var _style = {};
        var border = lodash_get(props, 'border');
        if (border === null) {
            _style.borderWidth = 0;
        }
        if (border) {
            var themeBorders = lodash_get(props, ['theme', 'borders']);
            if (themeBorders[border]) {
                _style = themeBorders[border];
            }
        }
        return _style;
    };

    var boxSizeUtils = function (props) {
        var _style = {};
        var h = lodash_get(props, 'h');
        if (h) {
            if (typeof h === 'string') {
                _style.height = h;
            }
            else if (typeof h === 'number') {
                if (h < 1) {
                    _style.height = h * 100 + "%";
                }
                else {
                    _style.height = h;
                }
            }
        }
        var w = lodash_get(props, 'w');
        if (w) {
            if (typeof w === 'string') {
                _style.width = w;
            }
            else if (typeof w === 'number') {
                if (w < 1) {
                    _style.width = w * 100 + "%";
                }
                else {
                    _style.width = w;
                }
            }
        }
        return _style;
    };

    var boxFlexUtils = function (props) {
        var _style = {};
        if (props.f && typeof props.f === 'number') {
            _style.flex = props.f;
        }
        var dir = lodash_get(props, 'dir');
        if (dir) {
            if (dir === 'row') {
                _style.flexDirection = 'row';
            }
            else if (dir === 'row-reverse') {
                _style.flexDirection = 'row-reverse';
            }
            else if (dir === 'col') {
                _style.flexDirection = 'column';
            }
            else if (dir === 'col-reverse') {
                _style.flexDirection = 'column-reverse';
            }
        }
        var align = lodash_get(props, 'align');
        if (align) {
            if (align === 'center') {
                _style.alignItems = 'center';
            }
            else if (align === 'start') {
                _style.alignItems = 'flex-start';
            }
            else if (align === 'end') {
                _style.alignItems = 'flex-end';
            }
            else if (align === 'stretch') {
                _style.alignItems = 'stretch';
            }
            else if (align === 'baseline') {
                _style.alignItems = 'baseline';
            }
        }
        var justify = lodash_get(props, 'justify');
        if (justify) {
            if (justify === 'center') {
                _style.justifyContent = 'center';
            }
            else if (justify === 'start') {
                _style.justifyContent = 'flex-start';
            }
            else if (justify === 'end') {
                _style.justifyContent = 'flex-end';
            }
            else if (justify === 'between') {
                _style.justifyContent = 'space-between';
            }
            else if (justify === 'around') {
                _style.justifyContent = 'space-around';
            }
            else if (justify === 'evenly') {
                _style.justifyContent = 'space-evenly';
            }
        }
        var self = lodash_get(props, 'self');
        if (self) {
            if (self === 'center') {
                _style.alignSelf = 'center';
            }
            else if (self === 'start') {
                _style.alignSelf = 'flex-start';
            }
            else if (self === 'end') {
                _style.alignSelf = 'flex-end';
            }
            else if (self === 'stretch') {
                _style.alignSelf = 'stretch';
            }
            else if (self === 'auto') {
                _style.alignSelf = 'auto';
            }
            else if (self === 'baseline') {
                _style.alignSelf = 'baseline';
            }
        }
        var flexWrap = lodash_get(props, 'flexWrap');
        if (flexWrap) {
            _style.flexWrap = flexWrap;
        }
        return _style;
    };

    var boxRowsUtils = function (props) {
        var newChild = props.children;
        var rows = lodash_get(props, 'rows');
        if (rows && Array.isArray(rows)) {
            newChild = React.Children.map(props.children, function (child, i) {
                if (child.type === Box$1) {
                    return React.cloneElement(child, {
                        f: rows[i] || 1,
                    });
                }
                throw new Error('Each child for a Box with rows need to be a Box');
            });
        }
        return newChild;
    };

    // TODO: Update this code
    var radiusUtils = function (props) {
        var _style = {};
        var themeRadius = lodash_get(props, ['theme', 'radius']);
        var radius = lodash_get(props, 'radius');
        var circle = lodash_get(props, 'circle');
        var avatar = lodash_get(props, 'avatar');
        var children = lodash_get(props, 'children');
        var newChildren = children;
        if (themeRadius) {
            if (avatar &&
                typeof circle === 'number' &&
                children &&
                React.Children.only(children).type === reactNative.Image) {
                newChildren = React.cloneElement(React.Children.only(children), {
                    style: {
                        borderRadius: circle / 2,
                        height: circle,
                        width: circle,
                    },
                });
                _style.borderRadius = circle / 2;
                _style.height = circle;
                _style.width = circle;
            }
            else if (typeof circle === 'number') {
                _style.borderRadius = circle / 2;
                _style.height = circle;
                _style.width = circle;
            }
            else if (radius) {
                if (typeof radius === 'string') {
                    var _radius = themeRadius[radius];
                    if (_radius) {
                        _style.borderRadius = _radius;
                    }
                    else {
                        if (radius === 'rounded') {
                            var height = lodash_get(props, ['size', 'height']);
                            var width = lodash_get(props, ['size', 'width']);
                            if (typeof height === 'number' && typeof width === 'number') {
                                _style.borderRadius = 99999;
                            }
                        }
                    }
                }
                else if (typeof radius === 'boolean') {
                    var base = lodash_get(themeRadius, 'base');
                    if (base) {
                        _style.borderRadius = base;
                    }
                }
                else if (typeof radius === 'number') {
                    _style.borderRadius = radius;
                }
            }
        }
        return {
            style: _style,
            children: newChildren,
        };
    };

    var shadowUtils = function (props) {
        var _style = {};
        var shadow = lodash_get(props, 'shadow');
        if (typeof shadow === 'number') {
            var themeShadows = lodash_get(props, ['theme', 'shadows']);
            var _shadow = themeShadows[shadow];
            if (_shadow) {
                _style = _shadow;
            }
        }
        return _style;
    };

    var opacityUtils = function (props) {
        var _style = {};
        var opacity = lodash_get(props, 'o');
        if (typeof opacity === 'string') {
            var themeOpacity = lodash_get(props, ['theme', 'opacity']);
            if (themeOpacity) {
                var _opacity = themeOpacity[opacity];
                if (_opacity) {
                    _style.opacity = _opacity;
                }
            }
        }
        else if (typeof opacity === 'number') {
            _style.opacity = opacity;
        }
        return _style;
    };

    var flattenStyle = function (style) {
        if (style === null || typeof style !== 'object') {
            return undefined;
        }
        if (!Array.isArray(style)) {
            return style;
        }
        var result = {};
        for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
            var computedStyle = flattenStyle(style[i]);
            if (computedStyle) {
                for (var key in computedStyle) {
                    // @ts-ignore
                    result[key] = computedStyle[key];
                }
            }
        }
        return result;
    };

    var positionUtils = function (props) {
        var _style = {};
        var position = lodash_get(props, 'position');
        if (position) {
            _style.position = position;
        }
        return _style;
    };

    var Box = function (_a) {
        var theme = _a.theme, m = _a.m, mb = _a.mb, mt = _a.mt, mr = _a.mr, ml = _a.ml, my = _a.my, mx = _a.mx, p = _a.p, pb = _a.pb, py = _a.py, pt = _a.pt, pr = _a.pr, pl = _a.pl, px = _a.px, radius = _a.radius, avatar = _a.avatar, circle = _a.circle, center = _a.center, border = _a.border, shadow = _a.shadow, f = _a.f, h = _a.h, w = _a.w, align = _a.align, justify = _a.justify, self = _a.self, dir = _a.dir, flexWrap = _a.flexWrap, o = _a.o, bg = _a.bg, rows = _a.rows, children = _a.children, position = _a.position, customStyle = _a.style, rest = __rest(_a, ["theme", "m", "mb", "mt", "mr", "ml", "my", "mx", "p", "pb", "py", "pt", "pr", "pl", "px", "radius", "avatar", "circle", "center", "border", "shadow", "f", "h", "w", "align", "justify", "self", "dir", "flexWrap", "o", "bg", "rows", "children", "position", "style"]);
        var _space = spaceUtils({
            m: m,
            mb: mb,
            mt: mt,
            mr: mr,
            ml: ml,
            my: my,
            mx: mx,
            p: p,
            pb: pb,
            py: py,
            pt: pt,
            pr: pr,
            pl: pl,
            px: px,
            theme: theme,
        });
        var _align = boxAlignUtils({ center: center });
        var _border = borderUtils({ border: border, theme: theme });
        var _shadow = shadowUtils({ shadow: shadow, theme: theme });
        var _size = boxSizeUtils({ w: w, h: h });
        var _flex = boxFlexUtils({ align: align, justify: justify, dir: dir, f: f, self: self, flexWrap: flexWrap });
        var _radius = radiusUtils({
            theme: theme,
            radius: radius,
            circle: circle,
            avatar: avatar,
            children: children,
            size: { height: h, width: w },
        });
        var _opacity = opacityUtils({ o: o, theme: theme });
        var _position = positionUtils({ position: position });
        var _style = {};
        var themeColor = lodash_get(theme, 'color');
        if (bg) {
            var color = themeColor[bg];
            if (color) {
                _style.backgroundColor = color;
            }
            else {
                _style.backgroundColor = bg;
            }
        }
        var newChild;
        if (avatar) {
            newChild = _radius.children;
        }
        else {
            newChild = boxRowsUtils({ rows: rows, children: children });
        }
        var _customStyle = flattenStyle(customStyle);
        var style = reactNative.StyleSheet.create({
            box: __assign({}, _style, _space, _align, _border, _shadow, _size, _flex, _radius.style, _opacity, _position, _customStyle),
        });
        return (React.createElement(reactNative.View, __assign({}, rest, { style: style.box }), newChild));
    };
    Box.defaultProps = {
        style: {},
    };
    Box.displayName = 'Box';
    var Box$1 = connect(Box);

    var textSizeUtils = function (props) {
        var _style = {};
        var themeSize = lodash_get(props, ['theme', 'text', 'size']);
        if (themeSize) {
            var base = lodash_get(themeSize, 'base');
            _style.fontSize = base;
            var size = lodash_get(props, 'size');
            if (size) {
                if (typeof size === 'string') {
                    var _size = themeSize[size];
                    if (typeof _size === 'number') {
                        _style.fontSize = _size;
                    }
                }
                else if (typeof size === 'number') {
                    _style.fontSize = size;
                }
            }
        }
        return _style;
    };

    var weightUtils = function (props) {
        var _style = {};
        var lightWeight = lodash_get(props, ['theme', 'text', 'weight', 'light']);
        var normalWeight = lodash_get(props, ['theme', 'text', 'weight', 'normal']);
        var boldWeight = lodash_get(props, ['theme', 'text', 'weight', 'bold']);
        _style.fontWeight = normalWeight;
        var light = lodash_get(props, 'light');
        if (light && lightWeight) {
            _style.fontWeight = lightWeight;
        }
        var normal = lodash_get(props, 'normal');
        if (normal && normalWeight) {
            _style.fontWeight = normalWeight;
        }
        var bold = lodash_get(props, 'bold');
        if (bold && boldWeight) {
            _style.fontWeight = boldWeight;
        }
        var weight = lodash_get(props, 'weight');
        if (typeof weight === 'string') {
            _style.fontWeight = weight;
        }
        return _style;
    };

    var colorUtils = function (props) {
        var _style = {};
        var themeColor = lodash_get(props, ['theme', 'color']);
        var color = lodash_get(props, 'color');
        if (themeColor) {
            var black = lodash_get(themeColor, 'black');
            if (black) {
                _style.color = black;
            }
            if (color) {
                var _color = themeColor[color];
                if (_color) {
                    _style.color = _color;
                }
                else {
                    _style.color = color;
                }
            }
        }
        return _style;
    };

    var textAlignUtils = function (props) {
        var _style = {};
        var center = lodash_get(props, 'center');
        if (center) {
            _style.textAlign = 'center';
        }
        var left = lodash_get(props, 'left');
        if (left) {
            _style.textAlign = 'left';
        }
        var right = lodash_get(props, 'right');
        if (right) {
            _style.textAlign = 'right';
        }
        return _style;
    };

    var letterSpacingUtils = function (props) {
        var _style = {};
        var themeSpacing = lodash_get(props, ['theme', 'text', 'spacing']);
        var ls = lodash_get(props, 'ls');
        if (themeSpacing) {
            _style.letterSpacing = lodash_get(props, ['theme', 'text', 'spacing', 'normal']);
        }
        if (typeof ls === 'string' && themeSpacing) {
            var space = themeSpacing[ls];
            if (space) {
                _style.letterSpacing = space;
            }
        }
        else if (typeof ls === 'number') {
            _style.letterSpacing = ls;
        }
        return _style;
    };

    var capitalizeText = function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };
    var capitalizeEachWords = function (str) {
        return str
            .split(' ')
            .map(capitalizeText)
            .join(' ')
            .trim();
    };
    var thousandSeparator = function (str) {
        return String(str).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    };
    var textManipulationUtils = function (props) {
        var newChild = props.children;
        if (typeof props.children === 'string') {
            var uppercase = lodash_get(props, 'uppercase');
            var lowercase = lodash_get(props, 'lowercase');
            var capitalize = lodash_get(props, 'capitalize');
            var capitalizeEach = lodash_get(props, 'capitalizeEach');
            var thousand = lodash_get(props, 'thousand');
            if (uppercase) {
                newChild = props.children.toUpperCase();
            }
            if (lowercase) {
                newChild = props.children.toLowerCase();
            }
            if (capitalize) {
                newChild = capitalizeText(props.children);
            }
            if (capitalizeEach) {
                newChild = capitalizeEachWords(props.children);
            }
            if (thousand) {
                newChild = thousandSeparator(props.children);
            }
        }
        return newChild;
    };

    var fontStyleUtils = function (props) {
        var _style = {};
        var italic = lodash_get(props, 'italic');
        if (italic) {
            _style.fontStyle = 'italic';
        }
        return _style;
    };

    var lineHeightUtils = function (props, fontSize) {
        var _style = {};
        var themeLineHeight = lodash_get(props, ['theme', 'text', 'lineHeight']);
        var height = lodash_get(props, 'lineH');
        if (typeof height === 'number') {
            _style.lineHeight = height;
        }
        else if (themeLineHeight && typeof fontSize === 'number') {
            var normal = lodash_get(themeLineHeight, 'normal');
            if (typeof normal === 'number') {
                _style.lineHeight = fontSize * normal;
            }
            if (height) {
                var _size = void 0;
                if (typeof height === 'string') {
                    _size = themeLineHeight[height];
                }
                else if (typeof height === 'number') {
                    _size = height;
                }
                if (typeof _size === 'number') {
                    _style.lineHeight = fontSize * _size;
                }
            }
        }
        return _style;
    };

    var decoUtils = function (props) {
        var _style = {};
        var deco = lodash_get(props, 'deco');
        if (typeof deco === 'string') {
            if (deco === 'none') {
                _style.textDecorationLine = 'none';
            }
            else if (deco === 'underline') {
                _style.textDecorationLine = 'underline';
            }
            else if (deco === 'through') {
                _style.textDecorationLine = 'line-through';
            }
            else if (deco === 'underline-through') {
                _style.textDecorationLine = 'underline line-through';
            }
        }
        return _style;
    };

    var fontFamilyUtils = function (props) {
        var _style = {};
        var themeFamily = lodash_get(props, ['theme', 'text', 'fonts']);
        if (themeFamily) {
            var base = lodash_get(themeFamily, 'base');
            if (typeof base === 'string') {
                _style.fontFamily = base;
            }
            var font = lodash_get(props, 'font');
            if (typeof font === 'string') {
                var _font = lodash_get(themeFamily, font);
                if (typeof _font === 'string') {
                    _style.fontFamily = _font;
                }
            }
        }
        return _style;
    };

    var Text = function (_a) {
        var theme = _a.theme, border = _a.border, color = _a.color, m = _a.m, mb = _a.mb, mt = _a.mt, mr = _a.mr, ml = _a.ml, my = _a.my, mx = _a.mx, p = _a.p, pb = _a.pb, pt = _a.pt, pr = _a.pr, pl = _a.pl, px = _a.px, py = _a.py, ls = _a.ls, lowercase = _a.lowercase, uppercase = _a.uppercase, capitalize = _a.capitalize, capitalizeEach = _a.capitalizeEach, thousand = _a.thousand, font = _a.font, center = _a.center, right = _a.right, left = _a.left, lineH = _a.lineH, size = _a.size, bold = _a.bold, normal = _a.normal, light = _a.light, weight = _a.weight, o = _a.o, italic = _a.italic, deco = _a.deco, customStyle = _a.style, children = _a.children, rest = __rest(_a, ["theme", "border", "color", "m", "mb", "mt", "mr", "ml", "my", "mx", "p", "pb", "pt", "pr", "pl", "px", "py", "ls", "lowercase", "uppercase", "capitalize", "capitalizeEach", "thousand", "font", "center", "right", "left", "lineH", "size", "bold", "normal", "light", "weight", "o", "italic", "deco", "style", "children"]);
        var _space = spaceUtils({
            m: m,
            mb: mb,
            mt: mt,
            mr: mr,
            ml: ml,
            my: my,
            mx: mx,
            p: p,
            pb: pb,
            py: py,
            pt: pt,
            pr: pr,
            pl: pl,
            px: px,
            theme: theme,
        });
        var _size = textSizeUtils({ size: size, theme: theme });
        var _weight = weightUtils({ bold: bold, normal: normal, light: light, theme: theme, weight: weight });
        var _color = colorUtils({ color: color, theme: theme });
        var _align = textAlignUtils({
            center: center,
            right: right,
            left: left,
            theme: theme,
        });
        var _spacing = letterSpacingUtils({ ls: ls, theme: theme });
        var _border = borderUtils({ border: border, theme: theme });
        var _fontStyle = fontStyleUtils({ italic: italic });
        var _lineHeight = lineHeightUtils({ lineH: lineH, theme: theme }, _size.fontSize);
        var _deco = decoUtils({ deco: deco });
        var _opacity = opacityUtils({ o: o, theme: theme });
        var _fontFamily = fontFamilyUtils({ font: font, theme: theme });
        var child = textManipulationUtils({
            capitalize: capitalize,
            capitalizeEach: capitalizeEach,
            lowercase: lowercase,
            uppercase: uppercase,
            children: children,
            thousand: thousand,
        });
        var _customStyle = flattenStyle(customStyle);
        var style = reactNative.StyleSheet.create({
            text: __assign({}, _space, _size, _weight, _color, _align, _spacing, _border, _fontStyle, _lineHeight, _deco, _opacity, _fontFamily, _customStyle),
        });
        return (
        // @ts-ignore
        React.createElement(reactNative.Text, __assign({}, rest, { style: style.text }), child));
    };
    Text.defaultProps = {
        style: {},
    };
    Text.displayName = 'Text';
    var Text$1 = connect(Text);

    exports.Box = Box$1;
    exports.UtilityThemeProvider = UtilityThemeProvider;
    exports.Text = Text$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ReactNativeDesignUtility.umd.js.map
