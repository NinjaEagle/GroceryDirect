import { IContext, IValidationResult, INode, IStateTreeNode, IJsonPatch, ObjectNode, IChildNodesMap, ModelPrimitive, IReferenceType } from "../../internal";
export declare enum TypeFlags {
    String = 1,
    Number = 2,
    Boolean = 4,
    Date = 8,
    Literal = 16,
    Array = 32,
    Map = 64,
    Object = 128,
    Frozen = 256,
    Optional = 512,
    Reference = 1024,
    Identifier = 2048,
    Late = 4096,
    Refinement = 8192,
    Union = 16384,
    Null = 32768,
    Undefined = 65536,
    Integer = 131072
}
export interface IType<C, S, T> {
    name: string;
    flags: TypeFlags;
    is(thing: any): thing is C | S | T;
    validate(thing: any, context: IContext): IValidationResult;
    create(snapshot?: C, environment?: any): T;
    isType: boolean;
    describe(): string;
    Type: T;
    SnapshotType: S;
    CreationType: C;
    instantiate(parent: INode | null, subpath: string, environment: any, initialValue?: any): INode;
    initializeChildNodes(node: INode, snapshot: any): IChildNodesMap | null;
    reconcile(current: INode, newValue: any): INode;
    getValue(node: INode): T;
    getSnapshot(node: INode, applyPostProcess?: boolean): S;
    applySnapshot(node: INode, snapshot: C): void;
    applyPatchLocally(node: INode, subpath: string, patch: IJsonPatch): void;
    getChildren(node: INode): ReadonlyArray<INode>;
    getChildNode(node: INode, key: string): INode;
    getChildType(key: string): IAnyType;
    removeChild(node: INode, subpath: string): void;
    isAssignableFrom(type: IAnyType): boolean;
    shouldAttachNode: boolean;
}
export interface IAnyType extends IType<any, any, any> {
}
export interface ISimpleType<T> extends IType<T, T, T> {
}
export declare type Primitives = ModelPrimitive | null | undefined;
export declare type TAndInterface<T, I> = (Exclude<T, Primitives> & I) | Extract<T, Primitives>;
export interface IComplexType<C, S, T> extends IType<C, S, T> {
    create(snapshot?: C, environment?: any): TAndInterface<T, {
        toJSON?(): S;
    } & IStateTreeNode<C, S>>;
}
export declare type ExtractC<T extends IAnyType> = T extends IType<infer C, any, any> ? C : never;
export declare type ExtractS<T extends IAnyType> = T extends IType<any, infer S, any> ? S : never;
export declare type ExtractT<T extends IAnyType> = T extends IType<any, any, infer X> ? X : never;
export declare type ExtractIStateTreeNode<IT extends IAnyType, C, S, T> = IT extends IReferenceType<infer RT> ? TAndInterface<ExtractT<RT>, IStateTreeNode<ExtractC<RT>, ExtractS<RT>>> : T extends ModelPrimitive ? T : TAndInterface<T, IStateTreeNode<C, S>>;
export declare type Instance<T> = T extends IStateTreeNode ? T : T extends IType<any, any, infer TT> ? TT : T;
export declare type SnapshotIn<T> = T extends IStateTreeNode<infer STNC, any> ? STNC : T extends IType<infer TC, any, any> ? TC : T;
export declare type SnapshotOut<T> = T extends IStateTreeNode<any, infer STNS> ? STNS : T extends IType<any, infer TS, any> ? TS : T;
/**
 * A type which is equivalent to the union of SnapshotIn and Instance types of a given typeof TYPE or typeof VARIABLE.
 * For primitives it defaults to the primitive itself.
 *
 * For example:
 * - SnapshotOrInstance<typeof ModelA> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>
 * - SnapshotOrInstance<typeof self.a (where self.a is a ModelA)> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>
 *
 * Usually you might want to use this when your model has a setter action that sets a property.
 *
 * @example
 * const ModelA = types.model({
 *   n: types.number
 * })
 *
 * const ModelB = types.model({
 *   innerModel: ModelA
 * }).actions(self => ({
 *   // this will accept as property both the snapshot and the instance, whichever is preferred
 *   setInnerModel(m: SnapshotOrInstance<typeof self.innerModel>) {
 *     self.innerModel = cast(m)
 *   }
 * }))
 */
export declare type SnapshotOrInstance<T> = SnapshotIn<T> | Instance<T>;
export declare abstract class ComplexType<C, S, T> implements IType<C, S, T> {
    readonly isType: boolean;
    readonly name: string;
    constructor(name: string);
    create(snapshot?: C, environment?: any): any;
    initializeChildNodes(node: INode, snapshot: any): IChildNodesMap | null;
    abstract instantiate(parent: INode | null, subpath: string, environment: any, initialValue: any): INode;
    abstract flags: TypeFlags;
    abstract describe(): string;
    abstract applySnapshot(node: INode, snapshot: any): void;
    abstract getDefaultSnapshot(): any;
    abstract getChildren(node: INode): ReadonlyArray<INode>;
    abstract getChildNode(node: INode, key: string): INode;
    abstract getValue(node: INode): T;
    abstract getSnapshot(node: INode, applyPostProcess?: boolean): any;
    abstract applyPatchLocally(node: INode, subpath: string, patch: IJsonPatch): void;
    abstract getChildType(key: string): IAnyType;
    abstract removeChild(node: INode, subpath: string): void;
    abstract isValidSnapshot(value: any, context: IContext): IValidationResult;
    abstract shouldAttachNode: boolean;
    processInitialSnapshot(childNodes: IChildNodesMap, snapshot: any): any;
    isAssignableFrom(type: IAnyType): boolean;
    validate(value: any, context: IContext): IValidationResult;
    is(value: any): value is S | T;
    reconcile(current: ObjectNode, newValue: any): INode;
    readonly Type: T;
    readonly SnapshotType: S;
    readonly CreationType: C;
}
export declare abstract class Type<C, S, T> extends ComplexType<C, S, T> implements IType<C, S, T> {
    constructor(name: string);
    abstract instantiate(parent: INode | null, subpath: string, environment: any, initialValue: any): INode;
    getValue(node: INode): any;
    getSnapshot(node: INode): any;
    getDefaultSnapshot(): undefined;
    applySnapshot(node: INode, snapshot: C): void;
    applyPatchLocally(node: INode, subpath: string, patch: IJsonPatch): void;
    getChildren(node: INode): INode[];
    getChildNode(node: INode, key: string): INode;
    getChildType(key: string): IAnyType;
    reconcile(current: INode, newValue: any): INode;
    removeChild(node: INode, subpath: string): void;
}
export declare function isType(value: any): value is IAnyType;
