import { IObservableArray, IArrayWillChange, IArrayWillSplice, IArrayChange, IArraySplice } from "mobx";
import { IJsonPatch, INode, IContext, IValidationResult, ComplexType, IComplexType, IType, TypeFlags, ObjectNode, IChildNodesMap, IAnyType } from "../../internal";
export interface IMSTArray<C, S, T> extends IObservableArray<T> {
}
export interface IArrayType<C, S, T> extends IComplexType<C[] | undefined, S[], IMSTArray<C, S, T>> {
    flags: TypeFlags.Optional;
}
export declare class ArrayType<C, S, T> extends ComplexType<C[] | undefined, S[], IMSTArray<C, S, T>> {
    shouldAttachNode: boolean;
    subType: IAnyType;
    readonly flags: TypeFlags;
    constructor(name: string, subType: IAnyType);
    describe(): string;
    createNewInstance(childNodes: IChildNodesMap): IObservableArray<INode>;
    finalizeNewInstance(node: INode): void;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: S): INode;
    initializeChildNodes(objNode: ObjectNode, snapshot?: S[]): IChildNodesMap;
    getChildren(node: ObjectNode): INode[];
    getChildNode(node: ObjectNode, key: string): INode;
    willChange(change: IArrayWillChange<any> | IArrayWillSplice<any>): Object | null;
    getValue(node: ObjectNode): any;
    getSnapshot(node: ObjectNode): any;
    processInitialSnapshot(childNodes: IChildNodesMap, snapshot: any): any;
    didChange(this: {}, change: IArrayChange<any> | IArraySplice<any>): void;
    applyPatchLocally(node: ObjectNode, subpath: string, patch: IJsonPatch): void;
    applySnapshot(node: ObjectNode, snapshot: any[]): void;
    getChildType(key: string): IAnyType;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    getDefaultSnapshot(): ReadonlyArray<any>;
    removeChild(node: ObjectNode, subpath: string): void;
}
/**
 * Creates an index based collection type who's children are all of a uniform declared type.
 *
 * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)
 *
 * @example
 * const Todo = types.model({
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.array(Todo)
 * })
 *
 * const s = TodoStore.create({ todos: [] })
 * unprotect(s) // needed to allow modifying outside of an action
 * s.todos.push({ task: "Grab coffee" })
 * console.log(s.todos[0]) // prints: "Grab coffee"
 *
 * @export
 * @alias types.array
 * @param {IType<S, T>} subtype
 * @returns {IComplexType<S[], IObservableArray<T>>}
 */
export declare function array<C, S, T>(subtype: IType<C, S, T>): IArrayType<C, S, T>;
export declare function isArrayType<IT extends IArrayType<any, any, any>>(type: IT): type is IT;
