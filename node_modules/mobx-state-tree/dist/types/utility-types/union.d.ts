import { IContext, IValidationResult, TypeFlags, IType, Type, INode, IAnyType, IComplexType, IModelType } from "../../internal";
export declare type ITypeDispatcher = (snapshot: any) => IAnyType;
export interface UnionOptions {
    eager?: boolean;
    dispatcher?: ITypeDispatcher;
}
export declare class Union extends Type<any, any, any> {
    readonly dispatcher?: ITypeDispatcher;
    readonly eager: boolean;
    readonly types: IAnyType[];
    readonly flags: TypeFlags;
    readonly shouldAttachNode: boolean;
    constructor(name: string, types: IAnyType[], options?: UnionOptions);
    isAssignableFrom(type: IAnyType): boolean;
    describe(): string;
    instantiate(parent: INode, subpath: string, environment: any, value: any): INode;
    reconcile(current: INode, newValue: any): INode;
    determineType(value: any): IAnyType | undefined;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
}
export declare function union<CA, SA, TA, CB, SB, TB>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>): IComplexType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>): IComplexType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>): IComplexType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>): IComplexType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IComplexType<CD, SD, TD>): IModelType<any, any, CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>): IComplexType<CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>): IComplexType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>): IComplexType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>): IComplexType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>): IComplexType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>): IComplexType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>): IComplexType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>, H: IModelType<any, any, CH, SH, TH>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>, H: IModelType<any, any, CH, SH, TH>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(options: UnionOptions, A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>, H: IModelType<any, any, CH, SH, TH>, I: IModelType<any, any, CI, SI, TI>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(A: IModelType<any, any, CA, SA, TA>, B: IModelType<any, any, CB, SB, TB>, C: IModelType<any, any, CC, SC, TC>, D: IModelType<any, any, CD, SD, TD>, E: IModelType<any, any, CE, SE, TE>, F: IModelType<any, any, CF, SF, TF>, G: IModelType<any, any, CG, SG, TG>, H: IModelType<any, any, CH, SH, TH>, I: IModelType<any, any, CI, SI, TI>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union<CA, SA, TA, CB, SB, TB>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>): IComplexType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>): IComplexType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>): IComplexType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>): IComplexType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>): IComplexType<CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>): IComplexType<CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>): IComplexType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>): IComplexType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>): IComplexType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>): IComplexType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>): IComplexType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>): IComplexType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>, H: IComplexType<CH, SH, TH>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>, H: IComplexType<CH, SH, TH>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(options: UnionOptions, A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>, H: IComplexType<CH, SH, TH>, I: IComplexType<CI, SI, TI>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(A: IComplexType<CA, SA, TA>, B: IComplexType<CB, SB, TB>, C: IComplexType<CC, SC, TC>, D: IComplexType<CD, SD, TD>, E: IComplexType<CE, SE, TE>, F: IComplexType<CF, SF, TF>, G: IComplexType<CG, SG, TG>, H: IComplexType<CH, SH, TH>, I: IComplexType<CI, SI, TI>): IComplexType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union<CA, SA, TA, CB, SB, TB>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>): IType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>): IType<CA | CB, SA | SB, TA | TB>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>): IType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>): IType<CA | CB | CC, SA | SB | SC, TA | TB | TC>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>): IType<CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>): IType<CA | CB | CC | CD, SA | SB | SC | SD, TA | TB | TC | TD>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>): IType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>): IType<CA | CB | CC | CD | CE, SA | SB | SC | SD | SE, TA | TB | TC | TD | TE>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>): IType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>): IType<CA | CB | CC | CD | CE | CF, SA | SB | SC | SD | SE | SF, TA | TB | TC | TD | TE | TF>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>): IType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>): IType<CA | CB | CC | CD | CE | CF | CG, SA | SB | SC | SD | SE | SF | SG, TA | TB | TC | TD | TE | TF | TG>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>, H: IType<CH, SH, TH>): IType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>, H: IType<CH, SH, TH>): IType<CA | CB | CC | CD | CE | CF | CG | CH, SA | SB | SC | SD | SE | SF | SG | SH, TA | TB | TC | TD | TE | TF | TG | TH>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(options: UnionOptions, A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>, H: IType<CH, SH, TH>, I: IType<CI, SI, TI>): IType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union<CA, SA, TA, CB, SB, TB, CC, SC, TC, CD, SD, TD, CE, SE, TE, CF, SF, TF, CG, SG, TG, CH, SH, TH, CI, SI, TI>(A: IType<CA, SA, TA>, B: IType<CB, SB, TB>, C: IType<CC, SC, TC>, D: IType<CD, SD, TD>, E: IType<CE, SE, TE>, F: IType<CF, SF, TF>, G: IType<CG, SG, TG>, H: IType<CH, SH, TH>, I: IType<CI, SI, TI>): IType<CA | CB | CC | CD | CE | CF | CG | CH | CI, SA | SB | SC | SD | SE | SF | SG | SH | SI, TA | TB | TC | TD | TE | TF | TG | TH | TI>;
export declare function union(...types: IAnyType[]): IAnyType;
export declare function union(dispatchOrType: UnionOptions | IAnyType, ...otherTypes: IAnyType[]): IAnyType;
export declare function isUnionType<IT extends IAnyType>(type: IT): type is IT;
