import { INode, Type, IType, TypeFlags, IContext, IValidationResult, ObjectNode, IAnyType } from "../../internal";
export interface CustomTypeOptions<S, T> {
    name: string;
    fromSnapshot(snapshot: S): T;
    toSnapshot(value: T): S;
    isTargetType(value: T | S): boolean;
    getValidationMessage(snapshot: S): string;
}
/**
 * Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.
 *
 * The signature of the options is:
 *
 * ```javascript
 * export interface CustomTypeOptions<S, T> {
 *     // Friendly name
 *     name: string
 *     // given a serialized value, how to turn it into the target type
 *     fromSnapshot(snapshot: S): T
 *     // return the serialization of the current value
 *     toSnapshot(value: T): S
 *     // if true, this is a converted value, if false, it's a snapshot
 *     isTargetType(value: T | S): boolean
 *     // a non empty string is assumed to be a validation error
 *     getValidationMessage?(snapshot: S): string
 * }
 * ```
 *
 * @export
 * @alias types.custom
 *
 * @example
 * const DecimalPrimitive = types.custom<string, Decimal>({
 *     name: "Decimal",
 *     fromSnapshot(value: string) {
 *         return new Decimal(value)
 *     },
 *     toSnapshot(value: Decimal) {
 *         return value.toString()
 *     },
 *     isTargetType(value: string | Decimal): boolean {
 *         return value instanceof Decimal
 *     },
 *     getValidationMessage(value: string): string {
 *         if (/^-?\d+\.\d+$/.test(value)) return "" // OK
 *         return `'${value}' doesn't look like a valid decimal number`
 *     }
 * })
 *
 * const Wallet = types.model({
 *     balance: DecimalPrimitive
 * })
 */
export declare function custom<S, T>(options: CustomTypeOptions<S, T>): IType<S | T, S, T>;
export declare class CustomType<S, T> extends Type<S, S, T> {
    protected readonly options: CustomTypeOptions<S, T>;
    readonly flags: TypeFlags;
    readonly shouldAttachNode: boolean;
    constructor(options: CustomTypeOptions<S, T>);
    describe(): string;
    isAssignableFrom(type: IAnyType): boolean;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    getValue(node: INode): any;
    getSnapshot(node: INode): any;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: any): INode;
    reconcile(current: INode, value: any): INode;
}
