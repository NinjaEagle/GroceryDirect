import * as tslib_1 from "tslib";
import { createNode, Type, TypeFlags, typeCheckSuccess, typeCheckFailure } from "../../internal";
/**
 * Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.
 *
 * The signature of the options is:
 *
 * ```javascript
 * export interface CustomTypeOptions<S, T> {
 *     // Friendly name
 *     name: string
 *     // given a serialized value, how to turn it into the target type
 *     fromSnapshot(snapshot: S): T
 *     // return the serialization of the current value
 *     toSnapshot(value: T): S
 *     // if true, this is a converted value, if false, it's a snapshot
 *     isTargetType(value: T | S): boolean
 *     // a non empty string is assumed to be a validation error
 *     getValidationMessage?(snapshot: S): string
 * }
 * ```
 *
 * @export
 * @alias types.custom
 *
 * @example
 * const DecimalPrimitive = types.custom<string, Decimal>({
 *     name: "Decimal",
 *     fromSnapshot(value: string) {
 *         return new Decimal(value)
 *     },
 *     toSnapshot(value: Decimal) {
 *         return value.toString()
 *     },
 *     isTargetType(value: string | Decimal): boolean {
 *         return value instanceof Decimal
 *     },
 *     getValidationMessage(value: string): string {
 *         if (/^-?\d+\.\d+$/.test(value)) return "" // OK
 *         return `'${value}' doesn't look like a valid decimal number`
 *     }
 * })
 *
 * const Wallet = types.model({
 *     balance: DecimalPrimitive
 * })
 */
export function custom(options) {
    return new CustomType(options);
}
var CustomType = /** @class */ (function (_super) {
    tslib_1.__extends(CustomType, _super);
    function CustomType(options) {
        var _this = _super.call(this, options.name) || this;
        _this.options = options;
        _this.flags = TypeFlags.Reference;
        _this.shouldAttachNode = false;
        return _this;
    }
    CustomType.prototype.describe = function () {
        return this.name;
    };
    CustomType.prototype.isAssignableFrom = function (type) {
        return type === this;
    };
    CustomType.prototype.isValidSnapshot = function (value, context) {
        if (this.options.isTargetType(value))
            return typeCheckSuccess();
        var typeError = this.options.getValidationMessage(value);
        if (typeError) {
            return typeCheckFailure(context, value, "Invalid value for type '" + this.name + "': " + typeError);
        }
        return typeCheckSuccess();
    };
    CustomType.prototype.getValue = function (node) {
        if (!node.isAlive)
            return undefined;
        return node.storedValue;
    };
    CustomType.prototype.getSnapshot = function (node) {
        return this.options.toSnapshot(node.storedValue);
    };
    CustomType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        var valueToStore = this.options.isTargetType(snapshot)
            ? snapshot
            : this.options.fromSnapshot(snapshot);
        return createNode(this, parent, subpath, environment, valueToStore);
    };
    CustomType.prototype.reconcile = function (current, value) {
        var isSnapshot = !this.options.isTargetType(value);
        var unchanged = current.type === this &&
            (isSnapshot ? value === current.snapshot : value === current.storedValue);
        if (unchanged)
            return current;
        var valueToStore = isSnapshot ? this.options.fromSnapshot(value) : value;
        var newNode = this.instantiate(current.parent, current.subpath, current._environment, valueToStore);
        current.die();
        return newNode;
    };
    return CustomType;
}(Type));
export { CustomType };
//# sourceMappingURL=custom.js.map